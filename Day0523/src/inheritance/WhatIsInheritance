<상속 ?>
- 상속을 정의하려면 자식 클래스 이름 뒤에 extends를 쓰고 부모 클래스의 이름을 적으면 된다.
- 다중 상속을 지원하지 않는다. 다중 상속이란 여러 개의 클래스로부터 상속 받는 것이다. 자바에서는 금지.
- 상속의 횟수에는 제한이 없다. (순차적으로 위(superclass)에서 아래(subclass)로 내려오는데엔 제한이 없다는 뜻이다.)
- 상속 계층 구조의 최상위에는 java.lang.Object 클래스가 있다.

<extends>
- 확장(또는 파생)을 의미한다. 즉 부모 클래스를 확장하여서 자식 클래스를 작성한다는 의미가 된다.
ex)
class subClass1 extends superClass1

자동차 - 스피드 메소드 ( 모든 차는 스피드를 가지고 있다.)
전기차, 경유차 - 소피드 메소드(필수니까 자동차 클래스를 확장해온다) / 전기차 - 전기차는 충전이 필요하므로 charge 메소드를 만든다. (경유차에는 해당이 안됨)

main에서 객체 생성할 땐 자식 클래스 객체를 생성해도 부모의 클래스 필드, 메소드가 사용 가능하다.
ex)
~main(String[] args){
	ElectricCar obj = new ElectricCar();
	obj.speed = 10;			// 15,16 = superClass method
	obj.setSpeed(60);
	obj.charge(10);			// 17 = subClass method
 
<member>
public, protected, default(부모와 자식이 같은 패키지에 있다면) - 상속o
private - 상속x
					
				public	protected	default	private
동일한 클래스		o			o				o			o
동일한 패키지		o			o				o			x
자식 클래스		o			o				o			x
다른 패키지		o			x				x			x

<생성자 부분>
- 자식 클래스 객체 안에는 부모 클래스에서 상속된 부분들이 들어있다. 따라서 자식 클래스 안의 부모 클래스 부분을 초기화하기 위하여 부모 클래스의 생성자도 호출되는 것이다.
- super()를 호출하면 부모 클래스의 생성자가 호출된다.
- super()을 안적고 자동으로 적용하고 싶을 땐 부모 클래스에 기본 생성자(매개변수가 없는 생성자)가 반드시 정의되어 있어야 한다.
- 생성자 호출할 땐 자식 생성자->부모 생성자 순으로 호출 된다.

<overrriding>
 - method overrriding은 자식 클래스가 부모 클래스의 메소드를 자신의 필요에 맞추어서 재정의하는 것이다. **이때 메소드의 이름이나 매개 변수, 반환형은 동일하여야 한다.**
 - shapeClass안에 draw() 메소드가 있을 때, 자식 클래스인 circleClass에서 부모클래스를 확장하여 draw를 쓸 때 자신에 맞게 재정의 (triangle, rectangle과는 다르게 쓰이기 떄문)
 - super는 상속 관계에서 부모 클래스의 메소드나 필드를 명시적으로 참조하기 위해 사용, overriding한 뒤 super를 사용하면 부모 클래스의 메소드 호출 가능
 - ***overloading : 같은 메소드명을 가진 여러 개의 메소드를 작성하는 것***
 
 <다형성(polymorphism)>
 - 오버로딩은 컴파일 시간에서의 다형성을 지원한다.
 - 객체들의 타입이 다르면 똑같은 메시지가 전달되더라도 서로 다른 동작을 하는 것
 
 <정적 메소드를 오버라이드 할 경우>
 - 자식 클래스가 부모 클래스의 정적 메소드와 동일한 정적 메소드를 정의하는 경우, 어떤 참조 변수를 통하여 호출되는지에 따라 달라진다.
 
 <상속 관계에서의 객체>
 - 부모 클래스 변수로 자식 클래스 객체를 참조할 수 있다. 이것을 업캐스팅(upCasting, 상형 형변환)이라고 한다.
 - 자식클래스의 필드에서 private를 사용할 경우 자식 클래스의 필드에는 접근이 안된다. get 이용
 - downcasting: 부모 객체를 자식 참조 변수로 참조하는 것이다. 이것은 묵시적으로는 안 되고 명시적으로 하여야 한다.